{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Cache library with LRU/LFU/FIFO policies support","text":""},{"location":"#base-class","title":"Base class","text":"<ul> <li>Cache class: caches::fixed_sized_cache</li> </ul>"},{"location":"#cache-policy-classes","title":"Cache policy classes","text":"<ul> <li>Cache policy abstract class: caches::ICachePolicy</li> <li>LRU cache policy class: caches::LRUCachePolicy</li> <li>LFU cache policy class: caches::LFUCachePolicy</li> <li>FIFO cache policy class: caches::FIFOCachePolicy</li> <li>No policy cache class: caches::NoCachePolicy</li> </ul>"},{"location":"#useful-links","title":"Useful links","text":"<ul> <li>Cache replacement policies</li> </ul>"},{"location":"LICENSE/","title":"License","text":"<p> BSD 3-Clause License</p> <p>Copyright (c) 2015-2021, Vladimir Petrigo All rights reserved.</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ul> <li> <p>Redistributions of source code must retain the above copyright notice, this   list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright notice,   this list of conditions and the following disclaimer in the documentation   and/or other materials provided with the distribution.</p> </li> <li> <p>Neither the name of the copyright holder nor the names of its   contributors may be used to endorse or promote products derived from   this software without specific prior written permission.</p> </li> </ul> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"api/cache/fixed_sized_cache/","title":"caches::fixed_sized_cache","text":"<p>Fixed sized cache that can be used with different policy types (e.g. LRU, FIFO, LFU)  More...</p> <p><code>#include &lt;cache.hpp&gt;</code></p>"},{"location":"api/cache/fixed_sized_cache/#public-types","title":"Public Types","text":"Name using typename std::unordered_map&lt; Key, Value &gt;::iterator iterator using typename std::unordered_map&lt; Key, Value &gt;::const_iterator const_iterator using typename std::lock_guard&lt; std::mutex &gt; operation_guard using typename std::function&lt; void(const Key &amp;key, const Value &amp;value)&gt; on_erase_cb"},{"location":"api/cache/fixed_sized_cache/#public-functions","title":"Public Functions","text":"Name fixed_sized_cache(size_t max_size, const Policy&lt; Key &gt; policy =Policy&lt; Key &gt;{}, on_erase_cb OnErase = {})Fixed sized cache constructor. ~fixed_sized_cache() void Put(const Key &amp; key, const Value &amp; value)Put element into the cache. std::pair&lt; const_iterator, bool &gt; TryGet(const Key &amp; key) constTry to get an element by the given key from the cache. const Value &amp; Get(const Key &amp; key) constGet element from the cache if present. bool Cached(const Key &amp; key) constCheck whether the given key is presented in the cache. std::size_t Size() constGet number of elements in cache. bool Remove(const Key &amp; key)"},{"location":"api/cache/fixed_sized_cache/#protected-functions","title":"Protected Functions","text":"Name void Clear() const_iterator begin() const const_iterator end() const void Insert(const Key &amp; key, const Value &amp; value) void Erase(const_iterator elem) void Erase(const Key &amp; key) void Update(const Key &amp; key, const Value &amp; value) const_iterator FindElem(const Key &amp; key) const std::pair&lt; const_iterator, bool &gt; GetInternal(const Key &amp; key) const"},{"location":"api/cache/fixed_sized_cache/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Key ,\ntypename Value ,\ntemplate&lt; typename &gt; class Policy =NoCachePolicy&gt;\nclass caches::fixed_sized_cache;\n</code></pre> <p>Fixed sized cache that can be used with different policy types (e.g. LRU, FIFO, LFU) </p> <p>Template Parameters: </p> <ul> <li>Key Type of a key (should be hashable) </li> <li>Value Type of a value stored in the cache </li> <li>Policy Type of a policy to be used with the cache </li> </ul>"},{"location":"api/cache/fixed_sized_cache/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/cache/fixed_sized_cache/#using-iterator","title":"using iterator","text":"<pre><code>using caches::fixed_sized_cache&lt; Key, Value, Policy &gt;::iterator =  typename std::unordered_map&lt;Key, Value&gt;::iterator;\n</code></pre>"},{"location":"api/cache/fixed_sized_cache/#using-const_iterator","title":"using const_iterator","text":"<pre><code>using caches::fixed_sized_cache&lt; Key, Value, Policy &gt;::const_iterator =  typename std::unordered_map&lt;Key, Value&gt;::const_iterator;\n</code></pre>"},{"location":"api/cache/fixed_sized_cache/#using-operation_guard","title":"using operation_guard","text":"<pre><code>using caches::fixed_sized_cache&lt; Key, Value, Policy &gt;::operation_guard =  typename std::lock_guard&lt;std::mutex&gt;;\n</code></pre>"},{"location":"api/cache/fixed_sized_cache/#using-on_erase_cb","title":"using on_erase_cb","text":"<pre><code>using caches::fixed_sized_cache&lt; Key, Value, Policy &gt;::on_erase_cb =  typename std::function&lt;void(const Key &amp;key, const Value &amp;value)&gt;;\n</code></pre>"},{"location":"api/cache/fixed_sized_cache/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/cache/fixed_sized_cache/#function-fixed_sized_cache","title":"function fixed_sized_cache","text":"<pre><code>inline explicit fixed_sized_cache(\nsize_t max_size,\nconst Policy&lt; Key &gt; policy =Policy&lt; Key &gt;{},\non_erase_cb OnErase =[](const Key &amp;, const Value &amp;) {}\n)\n</code></pre> <p>Fixed sized cache constructor. </p> <p>Parameters: </p> <ul> <li>max_size Maximum size of the cache </li> <li>policy Cache policy to use </li> <li>OnErase on_erase_cb function to be called when cache's element get erased </li> </ul> <p>Exceptions: </p> <ul> <li>std::invalid_argument </li> </ul>"},{"location":"api/cache/fixed_sized_cache/#function-fixed_sized_cache_1","title":"function ~fixed_sized_cache","text":"<pre><code>inline ~fixed_sized_cache()\n</code></pre>"},{"location":"api/cache/fixed_sized_cache/#function-put","title":"function Put","text":"<pre><code>inline void Put(\nconst Key &amp; key,\nconst Value &amp; value\n)\n</code></pre> <p>Put element into the cache. </p> <p>Parameters: </p> <ul> <li>key Key value to use </li> <li>value Value to assign to the given key </li> </ul>"},{"location":"api/cache/fixed_sized_cache/#function-tryget","title":"function TryGet","text":"<pre><code>inline std::pair&lt; const_iterator, bool &gt; TryGet(\nconst Key &amp; key\n) const\n</code></pre> <p>Try to get an element by the given key from the cache. </p> <p>Parameters: </p> <ul> <li>key Get element by key </li> </ul> <p>Return: Pair of iterator that points to the element and boolean value that shows whether get operation has been successful or not. If pair's boolean value is false, the element is not presented in the cache. If pair's boolean value is true, returned iterator can be used to get access to the element </p>"},{"location":"api/cache/fixed_sized_cache/#function-get","title":"function Get","text":"<pre><code>inline const Value &amp; Get(\nconst Key &amp; key\n) const\n</code></pre> <p>Get element from the cache if present. </p> <p>Parameters: </p> <ul> <li>key Get element by key </li> </ul> <p>Exceptions: </p> <ul> <li>std::range_error </li> </ul> <p>Return: Reference to the value stored by the specified key in the cache </p> <p>Warning: This method will change in the future with an optional class capabilities to avoid throwing exceptions </p>"},{"location":"api/cache/fixed_sized_cache/#function-cached","title":"function Cached","text":"<pre><code>inline bool Cached(\nconst Key &amp; key\n) const\n</code></pre> <p>Check whether the given key is presented in the cache. </p> <p>Parameters: </p> <ul> <li>key Element key to check </li> </ul> <p>Returns: </p> <ul> <li>true Element is presented in the case </li> <li>false Element is not presented in the case </li> </ul>"},{"location":"api/cache/fixed_sized_cache/#function-size","title":"function Size","text":"<pre><code>inline std::size_t Size() const\n</code></pre> <p>Get number of elements in cache. </p> <p>Return: Number of elements currently stored in the cache </p>"},{"location":"api/cache/fixed_sized_cache/#function-remove","title":"function Remove","text":"<pre><code>inline bool Remove(\nconst Key &amp; key\n)\n</code></pre> <p>Parameters: </p> <ul> <li>key Key parameter </li> </ul> <p>Returns: </p> <ul> <li>true if an element specified by key was found and deleted </li> <li>false if an element is not present in a cache </li> </ul> <p>Remove an element specified by key </p>"},{"location":"api/cache/fixed_sized_cache/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"api/cache/fixed_sized_cache/#function-clear","title":"function Clear","text":"<pre><code>inline void Clear()\n</code></pre>"},{"location":"api/cache/fixed_sized_cache/#function-begin","title":"function begin","text":"<pre><code>inline const_iterator begin() const\n</code></pre>"},{"location":"api/cache/fixed_sized_cache/#function-end","title":"function end","text":"<pre><code>inline const_iterator end() const\n</code></pre>"},{"location":"api/cache/fixed_sized_cache/#function-insert","title":"function Insert","text":"<pre><code>inline void Insert(\nconst Key &amp; key,\nconst Value &amp; value\n)\n</code></pre>"},{"location":"api/cache/fixed_sized_cache/#function-erase","title":"function Erase","text":"<pre><code>inline void Erase(\nconst_iterator elem\n)\n</code></pre>"},{"location":"api/cache/fixed_sized_cache/#function-erase_1","title":"function Erase","text":"<pre><code>inline void Erase(\nconst Key &amp; key\n)\n</code></pre>"},{"location":"api/cache/fixed_sized_cache/#function-update","title":"function Update","text":"<pre><code>inline void Update(\nconst Key &amp; key,\nconst Value &amp; value\n)\n</code></pre>"},{"location":"api/cache/fixed_sized_cache/#function-findelem","title":"function FindElem","text":"<pre><code>inline const_iterator FindElem(\nconst Key &amp; key\n) const\n</code></pre>"},{"location":"api/cache/fixed_sized_cache/#function-getinternal","title":"function GetInternal","text":"<pre><code>inline std::pair&lt; const_iterator, bool &gt; GetInternal(\nconst Key &amp; key\n) const\n</code></pre>"},{"location":"api/policy/cache_policy_interface/","title":"caches::ICachePolicy","text":"<p>Cache policy abstract base class.  More...</p> <p><code>#include &lt;cache_policy.hpp&gt;</code></p> <p>Inherited by caches::FIFOCachePolicy&lt; Key &gt;, caches::LFUCachePolicy&lt; Key &gt;, caches::LRUCachePolicy&lt; Key &gt;, caches::NoCachePolicy&lt; Key &gt;</p>"},{"location":"api/policy/cache_policy_interface/#public-functions","title":"Public Functions","text":"Name virtual ~ICachePolicy() =default virtual void Insert(const Key &amp; key) =0Handle element insertion in a cache. virtual void Touch(const Key &amp; key) =0Handle request to the key-element in a cache. virtual void Erase(const Key &amp; key) =0Handle element deletion from a cache. virtual const Key &amp; ReplCandidate() const =0Return a key of a replacement candidate."},{"location":"api/policy/cache_policy_interface/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Key &gt;\nclass caches::ICachePolicy;\n</code></pre> <p>Cache policy abstract base class. </p> <p>Template Parameters: </p> <ul> <li>Key Type of a key a policy works with </li> </ul>"},{"location":"api/policy/cache_policy_interface/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/policy/cache_policy_interface/#function-icachepolicy","title":"function ~ICachePolicy","text":"<pre><code>virtual ~ICachePolicy() =default\n</code></pre>"},{"location":"api/policy/cache_policy_interface/#function-insert","title":"function Insert","text":"<pre><code>virtual void Insert(\nconst Key &amp; key\n) =0\n</code></pre> <p>Handle element insertion in a cache. </p> <p>Parameters: </p> <ul> <li>key Key that should be used by the policy </li> </ul> <p>Reimplemented by: caches::LFUCachePolicy::Insert, caches::FIFOCachePolicy::Insert, caches::LRUCachePolicy::Insert, caches::NoCachePolicy::Insert</p>"},{"location":"api/policy/cache_policy_interface/#function-touch","title":"function Touch","text":"<pre><code>virtual void Touch(\nconst Key &amp; key\n) =0\n</code></pre> <p>Handle request to the key-element in a cache. </p> <p>Parameters: </p> <ul> <li>key </li> </ul> <p>Reimplemented by: caches::FIFOCachePolicy::Touch, caches::NoCachePolicy::Touch, caches::LFUCachePolicy::Touch, caches::LRUCachePolicy::Touch</p>"},{"location":"api/policy/cache_policy_interface/#function-erase","title":"function Erase","text":"<pre><code>virtual void Erase(\nconst Key &amp; key\n) =0\n</code></pre> <p>Handle element deletion from a cache. </p> <p>Parameters: </p> <ul> <li>key Key that should be used by the policy </li> </ul> <p>Reimplemented by: caches::LRUCachePolicy::Erase, caches::FIFOCachePolicy::Erase, caches::LFUCachePolicy::Erase, caches::NoCachePolicy::Erase</p>"},{"location":"api/policy/cache_policy_interface/#function-replcandidate","title":"function ReplCandidate","text":"<pre><code>virtual const Key &amp; ReplCandidate() const =0\n</code></pre> <p>Return a key of a replacement candidate. </p> <p>Return: Replacement candidate according to selected policy </p> <p>Reimplemented by: caches::FIFOCachePolicy::ReplCandidate, caches::LFUCachePolicy::ReplCandidate, caches::LRUCachePolicy::ReplCandidate, caches::NoCachePolicy::ReplCandidate</p>"},{"location":"api/policy/fifo_cache_policy/","title":"caches::FIFOCachePolicy","text":"<p>FIFO (First in, first out) cache policy.  More...</p> <p><code>#include &lt;fifo_cache_policy.hpp&gt;</code></p> <p>Inherits from caches::ICachePolicy&lt; Key &gt;</p>"},{"location":"api/policy/fifo_cache_policy/#public-functions","title":"Public Functions","text":"Name FIFOCachePolicy() =default ~FIFOCachePolicy() =default virtual void Insert(const Key &amp; key) overrideHandle element insertion in a cache. virtual void Touch(const Key &amp; key) overrideHandle request to the key-element in a cache. virtual void Erase(const Key &amp; key) overrideHandle element deletion from a cache. virtual const Key &amp; ReplCandidate() const overrideReturn a key of a replacement candidate."},{"location":"api/policy/fifo_cache_policy/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from caches::ICachePolicy&lt; Key &gt;</p> Name virtual ~ICachePolicy() =default"},{"location":"api/policy/fifo_cache_policy/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Key &gt;\nclass caches::FIFOCachePolicy;\n</code></pre> <p>FIFO (First in, first out) cache policy. </p> <p>Template Parameters: </p> <ul> <li>Key Type of a key a policy works with </li> </ul> <p>FIFO policy in the case of replacement removes the first added element.</p> <p>That is, consider the following key adding sequence: </p> <pre><code>A -&gt; B -&gt; C -&gt; ...\n</code></pre> <p>In the case a cache reaches its capacity, the FIFO replacement candidate policy returns firstly added element <code>A</code>. To show that: </p> <pre><code># New key: X\nInitial state: A -&gt; B -&gt; C -&gt; ...\nReplacement candidate: A\nFinal state: B -&gt; C -&gt; ... -&gt; X -&gt; ...\n</code></pre> <p>An so on, the next candidate will be <code>B</code>, then <code>C</code>, etc. </p>"},{"location":"api/policy/fifo_cache_policy/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/policy/fifo_cache_policy/#function-fifocachepolicy","title":"function FIFOCachePolicy","text":"<pre><code>FIFOCachePolicy() =default\n</code></pre>"},{"location":"api/policy/fifo_cache_policy/#function-fifocachepolicy_1","title":"function ~FIFOCachePolicy","text":"<pre><code>~FIFOCachePolicy() =default\n</code></pre>"},{"location":"api/policy/fifo_cache_policy/#function-insert","title":"function Insert","text":"<pre><code>inline virtual void Insert(\nconst Key &amp; key\n) override\n</code></pre> <p>Handle element insertion in a cache. </p> <p>Parameters: </p> <ul> <li>key Key that should be used by the policy </li> </ul> <p>Reimplements: caches::ICachePolicy::Insert</p>"},{"location":"api/policy/fifo_cache_policy/#function-touch","title":"function Touch","text":"<pre><code>inline virtual void Touch(\nconst Key &amp; key\n) override\n</code></pre> <p>Handle request to the key-element in a cache. </p> <p>Parameters: </p> <ul> <li>key </li> </ul> <p>Reimplements: caches::ICachePolicy::Touch</p>"},{"location":"api/policy/fifo_cache_policy/#function-erase","title":"function Erase","text":"<pre><code>inline virtual void Erase(\nconst Key &amp; key\n) override\n</code></pre> <p>Handle element deletion from a cache. </p> <p>Parameters: </p> <ul> <li>key Key that should be used by the policy </li> </ul> <p>Reimplements: caches::ICachePolicy::Erase</p>"},{"location":"api/policy/fifo_cache_policy/#function-replcandidate","title":"function ReplCandidate","text":"<pre><code>inline virtual const Key &amp; ReplCandidate() const override\n</code></pre> <p>Return a key of a replacement candidate. </p> <p>Return: Replacement candidate according to selected policy </p> <p>Reimplements: caches::ICachePolicy::ReplCandidate</p>"},{"location":"api/policy/lfu_cache_policy/","title":"caches::LFUCachePolicy","text":"<p>LFU (Least frequently used) cache policy.  More...</p> <p><code>#include &lt;lfu_cache_policy.hpp&gt;</code></p> <p>Inherits from caches::ICachePolicy&lt; Key &gt;</p>"},{"location":"api/policy/lfu_cache_policy/#public-types","title":"Public Types","text":"Name using typename std::multimap&lt; std::size_t, Key &gt;::iterator lfu_iterator"},{"location":"api/policy/lfu_cache_policy/#public-functions","title":"Public Functions","text":"Name LFUCachePolicy() =default ~LFUCachePolicy() override =default virtual void Insert(const Key &amp; key) overrideHandle element insertion in a cache. virtual void Touch(const Key &amp; key) overrideHandle request to the key-element in a cache. virtual void Erase(const Key &amp; key) overrideHandle element deletion from a cache. virtual const Key &amp; ReplCandidate() const overrideReturn a key of a replacement candidate."},{"location":"api/policy/lfu_cache_policy/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from caches::ICachePolicy&lt; Key &gt;</p> Name virtual ~ICachePolicy() =default"},{"location":"api/policy/lfu_cache_policy/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Key &gt;\nclass caches::LFUCachePolicy;\n</code></pre> <p>LFU (Least frequently used) cache policy. </p> <p>Template Parameters: </p> <ul> <li>Key Type of a key a policy works with </li> </ul> <p>LFU policy in the case of replacement removes the least frequently used element.</p> <p>Each access to an element in the cache increments internal counter (frequency) that represents how many times that particular key has been accessed by someone. When a replacement has to occur the LFU policy just takes a look onto keys' frequencies and remove the least used one. E.g. cache of two elements where <code>A</code> has been accessed 10 times and <code>B</code> \u2013 only 2. When you want to add a key <code>C</code> the LFU policy returns <code>B</code> as a replacement candidate. </p>"},{"location":"api/policy/lfu_cache_policy/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/policy/lfu_cache_policy/#using-lfu_iterator","title":"using lfu_iterator","text":"<pre><code>using caches::LFUCachePolicy&lt; Key &gt;::lfu_iterator =  typename std::multimap&lt;std::size_t, Key&gt;::iterator;\n</code></pre>"},{"location":"api/policy/lfu_cache_policy/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/policy/lfu_cache_policy/#function-lfucachepolicy","title":"function LFUCachePolicy","text":"<pre><code>LFUCachePolicy() =default\n</code></pre>"},{"location":"api/policy/lfu_cache_policy/#function-lfucachepolicy_1","title":"function ~LFUCachePolicy","text":"<pre><code>~LFUCachePolicy() override =default\n</code></pre>"},{"location":"api/policy/lfu_cache_policy/#function-insert","title":"function Insert","text":"<pre><code>inline virtual void Insert(\nconst Key &amp; key\n) override\n</code></pre> <p>Handle element insertion in a cache. </p> <p>Parameters: </p> <ul> <li>key Key that should be used by the policy </li> </ul> <p>Reimplements: caches::ICachePolicy::Insert</p>"},{"location":"api/policy/lfu_cache_policy/#function-touch","title":"function Touch","text":"<pre><code>inline virtual void Touch(\nconst Key &amp; key\n) override\n</code></pre> <p>Handle request to the key-element in a cache. </p> <p>Parameters: </p> <ul> <li>key </li> </ul> <p>Reimplements: caches::ICachePolicy::Touch</p>"},{"location":"api/policy/lfu_cache_policy/#function-erase","title":"function Erase","text":"<pre><code>inline virtual void Erase(\nconst Key &amp; key\n) override\n</code></pre> <p>Handle element deletion from a cache. </p> <p>Parameters: </p> <ul> <li>key Key that should be used by the policy </li> </ul> <p>Reimplements: caches::ICachePolicy::Erase</p>"},{"location":"api/policy/lfu_cache_policy/#function-replcandidate","title":"function ReplCandidate","text":"<pre><code>inline virtual const Key &amp; ReplCandidate() const override\n</code></pre> <p>Return a key of a replacement candidate. </p> <p>Return: Replacement candidate according to selected policy </p> <p>Reimplements: caches::ICachePolicy::ReplCandidate</p>"},{"location":"api/policy/lru_cache_policy/","title":"caches::LRUCachePolicy","text":"<p>LRU (Least Recently Used) cache policy.  More...</p> <p><code>#include &lt;lru_cache_policy.hpp&gt;</code></p> <p>Inherits from caches::ICachePolicy&lt; Key &gt;</p>"},{"location":"api/policy/lru_cache_policy/#public-types","title":"Public Types","text":"Name using typename std::list&lt; Key &gt;::iterator lru_iterator"},{"location":"api/policy/lru_cache_policy/#public-functions","title":"Public Functions","text":"Name LRUCachePolicy() =default ~LRUCachePolicy() =default virtual void Insert(const Key &amp; key) overrideHandle element insertion in a cache. virtual void Touch(const Key &amp; key) overrideHandle request to the key-element in a cache. virtual void Erase(const Key &amp; key) overrideHandle element deletion from a cache. virtual const Key &amp; ReplCandidate() const overrideReturn a key of a replacement candidate."},{"location":"api/policy/lru_cache_policy/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from caches::ICachePolicy&lt; Key &gt;</p> Name virtual ~ICachePolicy() =default"},{"location":"api/policy/lru_cache_policy/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Key &gt;\nclass caches::LRUCachePolicy;\n</code></pre> <p>LRU (Least Recently Used) cache policy. </p> <p>Template Parameters: </p> <ul> <li>Key Type of a key a policy works with </li> </ul> <p>LRU policy in the case of replacement removes the least recently used element. That is, in the case of replacement necessity, that cache policy returns a key that has not been touched recently. For example, cache maximum size is 3 and 3 elements have been added - <code>A</code>, <code>B</code>, <code>C</code>. Then the following actions were made: </p> <pre><code>Cache placement order: A, B, C\nCache elements: A, B, C\n# Cache access:\n- A touched, B touched\n# LRU element in the cache: C\n# Cache access:\n- B touched, C touched\n# LRU element in the cache: A\n# Put new element: D\n# LRU replacement candidate: A\n\nCache elements: B, C, D\n</code></pre>"},{"location":"api/policy/lru_cache_policy/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/policy/lru_cache_policy/#using-lru_iterator","title":"using lru_iterator","text":"<pre><code>using caches::LRUCachePolicy&lt; Key &gt;::lru_iterator =  typename std::list&lt;Key&gt;::iterator;\n</code></pre>"},{"location":"api/policy/lru_cache_policy/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/policy/lru_cache_policy/#function-lrucachepolicy","title":"function LRUCachePolicy","text":"<pre><code>LRUCachePolicy() =default\n</code></pre>"},{"location":"api/policy/lru_cache_policy/#function-lrucachepolicy_1","title":"function ~LRUCachePolicy","text":"<pre><code>~LRUCachePolicy() =default\n</code></pre>"},{"location":"api/policy/lru_cache_policy/#function-insert","title":"function Insert","text":"<pre><code>inline virtual void Insert(\nconst Key &amp; key\n) override\n</code></pre> <p>Handle element insertion in a cache. </p> <p>Parameters: </p> <ul> <li>key Key that should be used by the policy </li> </ul> <p>Reimplements: caches::ICachePolicy::Insert</p>"},{"location":"api/policy/lru_cache_policy/#function-touch","title":"function Touch","text":"<pre><code>inline virtual void Touch(\nconst Key &amp; key\n) override\n</code></pre> <p>Handle request to the key-element in a cache. </p> <p>Parameters: </p> <ul> <li>key </li> </ul> <p>Reimplements: caches::ICachePolicy::Touch</p>"},{"location":"api/policy/lru_cache_policy/#function-erase","title":"function Erase","text":"<pre><code>inline virtual void Erase(\nconst Key &amp; key\n) override\n</code></pre> <p>Handle element deletion from a cache. </p> <p>Parameters: </p> <ul> <li>key Key that should be used by the policy </li> </ul> <p>Reimplements: caches::ICachePolicy::Erase</p>"},{"location":"api/policy/lru_cache_policy/#function-replcandidate","title":"function ReplCandidate","text":"<pre><code>inline virtual const Key &amp; ReplCandidate() const override\n</code></pre> <p>Return a key of a replacement candidate. </p> <p>Return: Replacement candidate according to selected policy </p> <p>Reimplements: caches::ICachePolicy::ReplCandidate</p>"},{"location":"api/policy/no_cache_policy/","title":"caches::NoCachePolicy","text":"<p>Basic no caching policy class.  More...</p> <p><code>#include &lt;cache_policy.hpp&gt;</code></p> <p>Inherits from caches::ICachePolicy&lt; Key &gt;</p>"},{"location":"api/policy/no_cache_policy/#public-functions","title":"Public Functions","text":"Name NoCachePolicy() =default ~NoCachePolicy() override =default virtual void Insert(const Key &amp; key) overrideHandle element insertion in a cache. virtual void Touch(const Key &amp; key) overrideHandle request to the key-element in a cache. virtual void Erase(const Key &amp; key) overrideHandle element deletion from a cache. virtual const Key &amp; ReplCandidate() const overrideReturn a key of a replacement candidate."},{"location":"api/policy/no_cache_policy/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from caches::ICachePolicy&lt; Key &gt;</p> Name virtual ~ICachePolicy() =default"},{"location":"api/policy/no_cache_policy/#detailed-description","title":"Detailed Description","text":"<pre><code>template &lt;typename Key &gt;\nclass caches::NoCachePolicy;\n</code></pre> <p>Basic no caching policy class. </p> <p>Template Parameters: </p> <ul> <li>Key Type of a key a policy works with </li> </ul> <p>Preserve any key provided. Erase procedure can get rid of any added keys without specific rules: a replacement candidate will be the first element in the underlying container. As unordered container can be used in the implementation there are no warranties that the first/last added key will be erased </p>"},{"location":"api/policy/no_cache_policy/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/policy/no_cache_policy/#function-nocachepolicy","title":"function NoCachePolicy","text":"<pre><code>NoCachePolicy() =default\n</code></pre>"},{"location":"api/policy/no_cache_policy/#function-nocachepolicy_1","title":"function ~NoCachePolicy","text":"<pre><code>~NoCachePolicy() override =default\n</code></pre>"},{"location":"api/policy/no_cache_policy/#function-insert","title":"function Insert","text":"<pre><code>inline virtual void Insert(\nconst Key &amp; key\n) override\n</code></pre> <p>Handle element insertion in a cache. </p> <p>Parameters: </p> <ul> <li>key Key that should be used by the policy </li> </ul> <p>Reimplements: caches::ICachePolicy::Insert</p>"},{"location":"api/policy/no_cache_policy/#function-touch","title":"function Touch","text":"<pre><code>inline virtual void Touch(\nconst Key &amp; key\n) override\n</code></pre> <p>Handle request to the key-element in a cache. </p> <p>Parameters: </p> <ul> <li>key </li> </ul> <p>Reimplements: caches::ICachePolicy::Touch</p>"},{"location":"api/policy/no_cache_policy/#function-erase","title":"function Erase","text":"<pre><code>inline virtual void Erase(\nconst Key &amp; key\n) override\n</code></pre> <p>Handle element deletion from a cache. </p> <p>Parameters: </p> <ul> <li>key Key that should be used by the policy </li> </ul> <p>Reimplements: caches::ICachePolicy::Erase</p>"},{"location":"api/policy/no_cache_policy/#function-replcandidate","title":"function ReplCandidate","text":"<pre><code>inline virtual const Key &amp; ReplCandidate() const override\n</code></pre> <p>Return a key of a replacement candidate. </p> <p>Return: Replacement candidate according to selected policy </p> <p>Reimplements: caches::ICachePolicy::ReplCandidate</p>"}]}